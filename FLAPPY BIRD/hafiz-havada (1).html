<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HafÄ±z Havada â€” Ramazan Ã–zel</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           DESIGN TOKENS â€” RAMADAN PALETTE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        :root {
            --wood-darkest:  #2C1A10;
            --wood-dark:     #3E2723;
            --wood-mid:      #5D4037;
            --wood-light:    #795548;
            --wood-grain:    #6D4C41;

            --gold-bright:   #FFD700;
            --gold-mid:      #FFC107;
            --gold-dark:     #E65100;
            --gold-glow:     rgba(255, 215, 0, 0.45);

            --cream:         #FFF8E1;
            --text-on-wood:  #FFE0B2;
            --red-alert:     #FF5252;
            --green-ok:      #66BB6A;

            --shadow-heavy:  rgba(0,0,0,0.70);
            --shadow-mid:    rgba(0,0,0,0.45);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESET & BASE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--wood-darkest);
            font-family: 'Fredoka', sans-serif;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           GAME CANVAS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #gameCanvas {
            display: block;
            position: fixed;
            top: 0; left: 0;
            z-index: 1;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LOADING SCREEN
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #loader {
            position: fixed;
            inset: 0;
            z-index: 999;
            background: var(--wood-darkest);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            transition: opacity 0.5s ease;
        }

        #loader.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loader-star {
            font-size: 52px;
            animation: spinGlow 1.5s linear infinite;
        }

        .loader-text {
            color: var(--gold-bright);
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 2px;
            animation: pulse 1s ease-in-out infinite alternate;
        }

        .loader-bar-track {
            width: 200px;
            height: 8px;
            background: var(--wood-mid);
            border-radius: 99px;
            overflow: hidden;
            border: 1px solid var(--wood-grain);
        }

        .loader-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--gold-mid), var(--gold-bright));
            border-radius: 99px;
            transition: width 0.3s ease;
        }

        @keyframes spinGlow {
            0%   { transform: rotate(0deg);   filter: drop-shadow(0 0 6px var(--gold-bright)); }
            50%  { filter: drop-shadow(0 0 18px var(--gold-bright)); }
            100% { transform: rotate(360deg); filter: drop-shadow(0 0 6px var(--gold-bright)); }
        }

        @keyframes pulse {
            from { opacity: 0.6; }
            to   { opacity: 1.0; }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HUD â€” LIVE SCORE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #hud-score {
            position: fixed;
            top: 9%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            font-size: 64px;
            font-weight: 600;
            color: #fff;
            /* Thick stroke via stacked text-shadows */
            text-shadow:
                 2px  2px 0 #000,
                -2px -2px 0 #000,
                 2px -2px 0 #000,
                -2px  2px 0 #000,
                 3px  0   0 #000,
                -3px  0   0 #000,
                 0    3px 0 #000,
                 0   -3px 0 #000;
            pointer-events: none;
            display: none;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           PANEL SYSTEM (WOODEN PLAQUE)
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .panel-overlay {
            position: fixed;
            inset: 0;
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.30);
            backdrop-filter: blur(2px);
        }

        .panel-overlay.hidden { display: none; }

        .wood-panel {
            position: relative;
            background:
                /* Wood grain overlay */
                repeating-linear-gradient(
                    92deg,
                    transparent,
                    transparent 18px,
                    rgba(0,0,0,0.04) 18px,
                    rgba(0,0,0,0.04) 19px
                ),
                /* Main gradient */
                linear-gradient(170deg,
                    #6D4C41 0%,
                    #4E342E 30%,
                    #3E2723 60%,
                    #2C1A10 100%
                );

            /* Layered border: brass outer + dark inner */
            border: 3px solid var(--wood-darkest);
            outline: 3px solid var(--gold-bright);
            outline-offset: -6px;

            border-radius: 18px;
            padding: 36px 52px 40px;
            min-width: 320px;
            max-width: 420px;
            width: 90vw;
            text-align: center;

            /* Metallic glow */
            box-shadow:
                0 0 0 6px var(--wood-darkest),
                0 0 28px var(--gold-glow),
                0 12px 40px var(--shadow-heavy),
                inset 0 1px 0 rgba(255,255,255,0.08);

            animation: panelPop 0.38s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes panelPop {
            from { opacity: 0; transform: scale(0.82) translateY(16px); }
            to   { opacity: 1; transform: scale(1)    translateY(0); }
        }

        /* Corner bolts */
        .wood-panel::before,
        .wood-panel::after {
            content: 'â¬¡';
            position: absolute;
            color: var(--gold-dark);
            font-size: 16px;
            top: 10px;
            line-height: 1;
            opacity: 0.7;
        }
        .wood-panel::before { left: 12px; }
        .wood-panel::after  { right: 12px; }

        /* â”€â”€â”€ Panel Header â”€â”€â”€ */
        .panel-crescent {
            font-size: 36px;
            margin-bottom: 4px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.6));
        }

        .panel-title {
            font-size: 46px;
            font-weight: 600;
            color: var(--gold-bright);
            letter-spacing: 1px;
            line-height: 1.1;
            text-shadow:
                2px 3px 0 var(--wood-darkest),
                0 0 20px var(--gold-glow);
            margin-bottom: 6px;
        }

        .panel-title.danger { color: var(--red-alert); text-shadow: 2px 3px 0 var(--wood-darkest); }

        .panel-subtitle {
            font-size: 17px;
            color: var(--text-on-wood);
            opacity: 0.85;
            margin-bottom: 28px;
            letter-spacing: 0.5px;
        }

        /* â”€â”€â”€ Stat Row â”€â”€â”€ */
        .stats-row {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 28px;
        }

        .stat-box {
            flex: 1;
            background: rgba(0,0,0,0.35);
            border: 1px solid var(--wood-grain);
            border-radius: 10px;
            padding: 12px 16px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .stat-label {
            color: #8D6E63;
            font-size: 11px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .stat-value {
            color: #fff;
            font-size: 32px;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .stat-value.gold { color: var(--gold-bright); }

        /* â”€â”€â”€ Button â”€â”€â”€ */
        .btn-wood {
            display: inline-block;
            background: linear-gradient(to bottom, #FFD54F 0%, #FFB300 50%, #FF8F00 100%);
            border: none;
            border-radius: 32px;
            padding: 14px 52px;
            font-family: 'Fredoka', sans-serif;
            font-size: 22px;
            font-weight: 600;
            color: var(--wood-darkest);
            cursor: pointer;
            letter-spacing: 1px;
            text-transform: uppercase;
            /* 3D effect */
            box-shadow:
                0 6px 0 #E65100,
                0 8px 12px rgba(0,0,0,0.4);
            transition: box-shadow 0.08s, transform 0.08s;
            -webkit-appearance: none;
        }

        .btn-wood:active,
        .btn-wood.pressed {
            transform: translateY(4px);
            box-shadow:
                0 2px 0 #E65100,
                0 3px 6px rgba(0,0,0,0.3);
        }

        .btn-wood:hover {
            background: linear-gradient(to bottom, #FFE082 0%, #FFD740 50%, #FFA000 100%);
        }

        /* â”€â”€â”€ Divider â”€â”€â”€ */
        .panel-divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold-dark), transparent);
            margin: 0 0 24px;
            opacity: 0.5;
        }

        /* Utility */
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• LOADING SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="loader">
        <div class="loader-star">â˜ª</div>
        <div class="loader-text">YÃœKLENÄ°YOR</div>
        <div class="loader-bar-track">
            <div class="loader-bar-fill" id="loader-bar"></div>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME CANVAS â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <canvas id="gameCanvas"></canvas>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• HUD â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="hud-score">0</div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN MENU â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="screen-menu" class="panel-overlay">
        <div class="wood-panel">
            <div class="panel-crescent">â˜ªï¸</div>
            <div class="panel-title">HAFIZ HAVADA</div>
            <div class="panel-subtitle">Ramazan Ã–zel âœ¨</div>
            <div class="panel-divider"></div>
            <button class="btn-wood" id="btn-start">BAÅLA</button>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME OVER SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="screen-gameover" class="panel-overlay hidden">
        <div class="wood-panel">
            <div class="panel-crescent">ğŸ’«</div>
            <div class="panel-title danger">OYUN BÄ°TTÄ°</div>
            <div class="panel-divider"></div>
            <div class="stats-row">
                <div class="stat-box">
                    <div class="stat-label">SKOR</div>
                    <div class="stat-value" id="final-score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">EN Ä°YÄ°</div>
                    <div class="stat-value gold" id="best-score">0</div>
                </div>
            </div>
            <button class="btn-wood" id="btn-retry">TEKRAR DENE</button>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• BACKGROUND MUSIC â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <audio id="bgMusic" loop>
        <source src="mÃ¼zik.mp3" type="audio/mpeg">
    </audio>

    <script>
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       HAFIZ HAVADA â€” RAMADAN EDITION
       Production Refactor â€” Senior Engineer Build
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    'use strict';

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       CONFIGURATION â€” All magic numbers live here
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const CONFIG = Object.freeze({
        // Physics
        GRAVITY:           0.07,
        LIFT:             -3.6,
        MAX_FALL_SPEED:    8.0,
        ROTATION_FACTOR:   3.5,   // degrees per unit velocity
        MAX_ROTATION_UP:  -45,    // deg (nose up)
        MAX_ROTATION_DOWN:  25,   // deg (nose down)

        // World
        GAME_SPEED:        2.0,
        BG_PARALLAX_SPEED: 0.5,

        // Pipes
        PIPE_SPAWN_DIST:   380,   // px between pipe leading edges
        PIPE_GAP:          205,   // vertical gap between top & bottom pipe
        PIPE_WIDTH:         95,   // for collision & fallback rendering
        PIPE_MIN_TOP:      115,   // min height for top pipe
        PIPE_MAX_BOTTOM_CLEAR: 100, // pixels of clear space above the floor

        // Bird â€” visually balanced size
        BIRD_W: 78,
        BIRD_H: 70,
        BIRD_START_X: 110,
        BIRD_HITBOX_SHRINK: 10,   // px inset on each side for forgiving hitbox

        // Camera shake
        SHAKE_FRAMES:  22,
        SHAKE_MAG:      9,

        // Assets
        ASSETS: {
            bg:   'rt.png',
            bird: 'dragon.png',
            pipe: 'br.png',
        }
    });

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       ASSET LOADER â€” Promise-based, no race conditions
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const AssetLoader = {
        /**
         * Load a list of {key, src} image descriptors.
         * Returns a Promise<Map<key, HTMLImageElement>>.
         * Progress callback receives 0.0â€“1.0.
         */
        load(manifest, onProgress) {
            const map = new Map();
            let loaded = 0;

            const promises = manifest.map(({ key, src }) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        map.set(key, img);
                        loaded++;
                        if (onProgress) onProgress(loaded / manifest.length);
                        resolve();
                    };
                    img.onerror = () => {
                        // Non-fatal: store null, game uses canvas fallbacks
                        map.set(key, null);
                        loaded++;
                        if (onProgress) onProgress(loaded / manifest.length);
                        resolve(); // resolve, not reject â€” graceful degradation
                    };
                    img.src = src;
                });
            });

            return Promise.all(promises).then(() => map);
        }
    };

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       UTILITY
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const Utils = {
        clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
        randInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    };

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       MAIN GAME CLASS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    class HafizHavada {
        constructor(canvas) {
            this.canvas  = canvas;
            this.ctx     = canvas.getContext('2d', { alpha: false });
            this.sprites = new Map();  // populated by AssetLoader
            this.state   = 'MENU';    // MENU | PLAYING | GAMEOVER
            this.score   = 0;
            this.highScore = parseInt(localStorage.getItem('hafiz_hs') || '0', 10);
            this.shakeTick = 0;

            // Sub-systems
            this.background = new Background(this);
            this.bird       = new Bird(this);
            this.pipes      = new PipeManager(this);

            this._bindEvents();
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
        }

        /* â”€â”€ Resize â”€â”€ */
        _resizeCanvas() {
            this.canvas.width  = window.innerWidth;
            this.canvas.height = window.innerHeight;
            // Re-centre bird on resize
            this.bird.groundY = this.canvas.height;
        }

        /* â”€â”€ Input â”€â”€ */
        _bindEvents() {
            const onInput = (e) => {
                if (e.type === 'touchstart') e.preventDefault();
                this._handleInput();
            };
            window.addEventListener('keydown',    (e) => { if (e.code === 'Space') { e.preventDefault(); this._handleInput(); } });
            window.addEventListener('touchstart', onInput, { passive: false });
            window.addEventListener('mousedown',  onInput);

            document.getElementById('btn-start').addEventListener('click',  () => this.startGame());
            document.getElementById('btn-retry').addEventListener('click',  () => this.startGame());
        }

        _handleInput() {
            if (this.state === 'PLAYING') {
                this.bird.flap();
            }
        }

        /* â”€â”€ State Transitions â”€â”€ */
        startGame() {
            this._hideAllScreens();
            document.getElementById('hud-score').style.display = 'block';

            const music = document.getElementById('bgMusic');
            if (music) music.play().catch(() => {});

            this.score     = 0;
            this.shakeTick = 0;
            this.bird.reset();
            this.pipes.reset();
            this._updateHUD();

            this.state = 'PLAYING';
        }

        triggerGameOver() {
            if (this.state === 'GAMEOVER') return;
            this.state     = 'GAMEOVER';
            this.shakeTick = CONFIG.SHAKE_FRAMES;

            if (this.score > this.highScore) {
                this.highScore = this.score;
                localStorage.setItem('hafiz_hs', this.highScore);
            }

            document.getElementById('final-score').textContent = this.score;
            document.getElementById('best-score').textContent  = this.highScore;
            document.getElementById('hud-score').style.display = 'none';

            // Small delay so the shake plays before the panel appears
            setTimeout(() => {
                document.getElementById('screen-gameover').classList.remove('hidden');
            }, 350);
        }

        addScore() {
            this.score++;
            this._updateHUD();
        }

        _updateHUD() {
            document.getElementById('hud-score').textContent = this.score;
        }

        _hideAllScreens() {
            document.getElementById('screen-menu').classList.add('hidden');
            document.getElementById('screen-gameover').classList.add('hidden');
        }

        /* â”€â”€ Camera Shake â”€â”€ */
        _applyShake() {
            if (this.shakeTick > 0) {
                const mag = CONFIG.SHAKE_MAG * (this.shakeTick / CONFIG.SHAKE_FRAMES);
                this.ctx.translate(
                    (Math.random() - 0.5) * mag,
                    (Math.random() - 0.5) * mag
                );
                this.shakeTick--;
            }
        }

        /* â”€â”€ Main Loop â”€â”€ */
        tick() {
            const { ctx, canvas } = this;

            // 1. Update
            if (this.state === 'PLAYING') {
                this.bird.update();
                this.pipes.update();
            }

            // 2. Render â€” wrap in save/restore for shake
            ctx.save();
            this._applyShake();

            this.background.draw();
            this.pipes.draw();

            if (this.state !== 'MENU') {
                this.bird.draw();
            } else {
                // Idle bob in menu
                this.bird.drawIdle();
            }

            ctx.restore();

            requestAnimationFrame(() => this.tick());
        }

        /** Called by AssetLoader after everything is ready */
        init(sprites) {
            this.sprites = sprites;

            // Hide loader with a fade
            const loader = document.getElementById('loader');
            loader.classList.add('fade-out');
            setTimeout(() => loader.classList.add('hidden'), 520);

            // Show menu
            document.getElementById('screen-menu').classList.remove('hidden');

            // Start loop
            this.tick();
        }
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       BACKGROUND
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    class Background {
        constructor(game) {
            this.game   = game;
            this.scrollX = 0;
        }

        draw() {
            const { ctx, canvas, sprites, state } = this.game;
            const img = sprites.get('bg');

            if (img) {
                // Two-panel seamless scroll
                ctx.drawImage(img, this.scrollX,                 0, canvas.width, canvas.height);
                ctx.drawImage(img, this.scrollX + canvas.width,  0, canvas.width, canvas.height);

                if (state === 'PLAYING') {
                    this.scrollX -= CONFIG.BG_PARALLAX_SPEED;
                    if (this.scrollX <= -canvas.width) this.scrollX = 0;
                }
            } else {
                // Fallback gradient sky
                const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                grad.addColorStop(0, '#1a237e');
                grad.addColorStop(0.4, '#283593');
                grad.addColorStop(1, '#1565c0');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       BIRD
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    class Bird {
        constructor(game) {
            this.game     = game;
            this.w        = CONFIG.BIRD_W;
            this.h        = CONFIG.BIRD_H;
            this.groundY  = game.canvas.height; // updated on resize
            this.reset();
        }

        reset() {
            const { canvas } = this.game;
            this.x        = CONFIG.BIRD_START_X;
            this.y        = canvas.height / 2;
            this.velocity = 0;
            this.rotation = 0;   // degrees
        }

        flap() {
            this.velocity = CONFIG.LIFT;
        }

        update() {
            const { canvas } = this.game;

            // Physics
            this.velocity += CONFIG.GRAVITY;
            this.velocity  = Utils.clamp(this.velocity, CONFIG.LIFT, CONFIG.MAX_FALL_SPEED);
            this.y        += this.velocity;

            // Visual rotation â€” smooth follow of velocity
            const targetRot = this.velocity * CONFIG.ROTATION_FACTOR;
            this.rotation = Utils.clamp(
                targetRot,
                CONFIG.MAX_ROTATION_UP,
                CONFIG.MAX_ROTATION_DOWN
            );

            // Floor collision
            if (this.y + this.h >= canvas.height) {
                this.y = canvas.height - this.h;
                this.game.triggerGameOver();
            }

            // Ceiling clamp (not game-over, just stop)
            if (this.y < 0) {
                this.y = 0;
                this.velocity = 0;
            }
        }

        /* Hit-box used for pipe collision â€” smaller than sprite */
        get hitbox() {
            const s = CONFIG.BIRD_HITBOX_SHRINK;
            return {
                x: this.x + s,
                y: this.y + s,
                w: this.w - s * 2,
                h: this.h - s * 2,
            };
        }

        draw() {
            this._renderAt(this.x, this.y, this.rotation);
        }

        /** Idle sinusoidal bob for menu screen */
        drawIdle() {
            const bobY = Math.sin(Date.now() / 320) * 14;
            this._renderAt(this.x, this.game.canvas.height / 2 + bobY, 0);
        }

        _renderAt(x, y, rotDeg) {
            const { ctx, sprites } = this.game;
            const img = sprites.get('bird');

            ctx.save();
            ctx.translate(x + this.w / 2, y + this.h / 2);
            ctx.rotate(rotDeg * Math.PI / 180);

            if (img) {
                ctx.drawImage(img, -this.w / 2, -this.h / 2, this.w, this.h);
            } else {
                // Fallback capsule
                ctx.fillStyle = '#FF8C00';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.w / 2, this.h / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(6, -4, 6, 5, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }
    }

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       PIPE MANAGER
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    class PipeManager {
        constructor(game) {
            this.game  = game;
            this.pipes = [];
        }

        reset() { this.pipes = []; }

        _spawnPipe() {
            const { canvas } = this.game;
            const maxTop = canvas.height - CONFIG.PIPE_GAP - CONFIG.PIPE_MAX_BOTTOM_CLEAR;
            const topH   = Utils.randInt(CONFIG.PIPE_MIN_TOP, maxTop);
            this.pipes.push({ x: canvas.width, topH, scored: false });
        }

        update() {
            const { canvas, bird } = this.game;
            const lastPipe = this.pipes[this.pipes.length - 1];

            // Spawn logic: fixed distance between leading edges
            if (!lastPipe || (canvas.width - lastPipe.x) >= CONFIG.PIPE_SPAWN_DIST) {
                this._spawnPipe();
            }

            for (let i = this.pipes.length - 1; i >= 0; i--) {
                const p = this.pipes[i];
                p.x -= CONFIG.GAME_SPEED;

                // â”€ Scoring â”€
                if (!p.scored && p.x + CONFIG.PIPE_WIDTH < bird.x) {
                    p.scored = true;
                    this.game.addScore();
                }

                // â”€ Collision â”€
                const hb = bird.hitbox;
                const pRight  = p.x + CONFIG.PIPE_WIDTH;
                const pBottom = p.topH + CONFIG.PIPE_GAP;
                const overlapX = hb.x < pRight && hb.x + hb.w > p.x;

                if (overlapX) {
                    const hitTop    = hb.y              < p.topH;
                    const hitBottom = hb.y + hb.h       > pBottom;
                    if (hitTop || hitBottom) {
                        this.game.triggerGameOver();
                    }
                }

                // â”€ Cleanup â”€
                if (p.x + CONFIG.PIPE_WIDTH < -10) {
                    this.pipes.splice(i, 1);
                }
            }
        }

        draw() {
            for (const p of this.pipes) {
                this._drawPipe(p);
            }
        }

        /**
         * _drawPipe â€” renders one top+bottom pipe pair using br.png.
         *
         * â•â•â• TOP PIPE (VERTICALLY FLIPPED) â•â•â•
         *
         *  Goal: br.png has its "mouth/cap" at the TOP of the image.
         *        For the top pipe we need the cap at the BOTTOM (facing down
         *        into the gap), so we flip the image vertically.
         *
         *  The top pipe must visually fill the region:
         *      y = 0  â†’  y = p.topH   (screen top down to the gap opening)
         *
         *  Technique â€” three canvas ops before drawImage:
         *    1. ctx.save()
         *    2. ctx.translate(p.x, p.topH)
         *       â†³ Moves the origin to the BOTTOM-LEFT corner of the top pipe.
         *    3. ctx.scale(1, -1)
         *       â†³ Flips Y axis. Now drawing at y=0 goes toward screen-top,
         *         and drawing at y=+H goes toward screen-bottom in real coords.
         *    4. ctx.drawImage(img, 0, 0, W, p.topH)
         *       â†³ In flipped space: the image draws FROM our origin UPWARD,
         *         spanning exactly p.topH pixels (fills screen top to gap).
         *         The cap (top of image) ends up at y=0 on screen.
         *         The shaft fills down to p.topH. âœ“
         *    5. ctx.restore()
         *
         * â•â•â• BOTTOM PIPE (NORMAL) â•â•â•
         *
         *  No transform needed. Draw from (p.x, p.topH + GAP) downward,
         *  height = canvas.height - bottomY to always fill to screen edge.
         *  The cap (top of image) sits right at the gap opening. âœ“
         */
        _drawPipe(p) {
            const { ctx, sprites, canvas } = this.game;
            const img     = sprites.get('pipe');
            const W       = CONFIG.PIPE_WIDTH;
            const GAP     = CONFIG.PIPE_GAP;
            const bottomY = p.topH + GAP;
            const botH    = canvas.height - bottomY; // fills to screen edge

            if (img) {
                // â”€â”€ TOP PIPE: flipped, cap faces DOWN into the gap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ctx.save();
                ctx.translate(p.x, p.topH); // origin = bottom-left of top pipe
                ctx.scale(1, -1);            // flip Y axis
                // Draw with height = p.topH so it fills from screen-top to gap
                ctx.drawImage(img, 0, 0, W, p.topH);
                ctx.restore();

                // â”€â”€ BOTTOM PIPE: normal, cap faces UP into the gap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ctx.drawImage(img, p.x, bottomY, W, botH > 0 ? botH : 0);

            } else {
                // â”€â”€ Fallback: colored rectangles when br.png fails to load â”€â”€

                // Top pipe body
                ctx.fillStyle = '#33691E';
                ctx.fillRect(p.x, 0, W, p.topH);
                // Top pipe cap (at the bottom of the top pipe = the "mouth")
                ctx.fillStyle = '#1B5E20';
                ctx.fillRect(p.x - 6, p.topH - 28, W + 12, 28);

                // Bottom pipe body
                ctx.fillStyle = '#33691E';
                ctx.fillRect(p.x, bottomY, W, botH);
                // Bottom pipe cap (at the top of the bottom pipe = the "mouth")
                ctx.fillStyle = '#1B5E20';
                ctx.fillRect(p.x - 6, bottomY, W + 12, 28);
            }
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BOOTSTRAP â€” Wait for DOM + Assets, then launch
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    window.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const game   = new HafizHavada(canvas);
        const bar    = document.getElementById('loader-bar');

        const manifest = [
            { key: 'bg',   src: CONFIG.ASSETS.bg   },
            { key: 'bird', src: CONFIG.ASSETS.bird  },
            { key: 'pipe', src: CONFIG.ASSETS.pipe  },
        ];

        AssetLoader.load(manifest, (progress) => {
            bar.style.width = (progress * 100) + '%';
        }).then((sprites) => {
            game.init(sprites);
        });
    });
    </script>
</body>
</html>
